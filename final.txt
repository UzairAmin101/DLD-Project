// Code your design here
`timescale 1ns / 1ps

module dff(D,clk,Q);
input D; // Data input 
input clk; // clock input 
output Q; // output Q 
reg Q;


always @(posedge clk) 
begin
 Q <= D; 
end 
endmodule

module clk_div_new(clk,clk_d);
  parameter div_value = 49999999;
  input clk;
  output clk_d;
  reg clk_d;
  reg [25:0]count;
  initial
    begin
      clk_d = 0;
      count = 0;
    end
  always @(posedge clk)
    begin
      if(count == div_value)
        count <=0;
      else
        count <=count + 1;
    end
  
  always @(posedge clk)
    begin
      if (count == div_value)
        clk_d = ~clk_d;
    end
endmodule

  module light_FSM(clk,red,green);
  input clk;
  wire state;
  reg next_state;
  wire clk_d;
  output red;
  output green;
  reg green;
  reg red;
  
    
    initial begin
      next_state <= 1;
      red <= 1;
      green <= 0;
  end
  
  clk_div_new c(clk,clk_d);
  dff(next_state,clk_d,state);
  
  
  always @(posedge clk_d)
    begin
      next_state <= ~state;
      
      if (state)
        begin
          green = ~green;
          red = ~red;
        end
        else begin
        green = ~green;
        red = ~red;
        end
      
    
    end
    
    endmodule

//module random(clk, n);
//  parameter n1 = 1;
//  parameter n2 = 3;
//  parameter n3 = 2;
  
//  input clk;
//  output reg [2:0] n;
  
//  initial begin
//    n = n1;
//  end
  
//  always @(posedge clk)
//    begin
//      if (n == n1)
//        n <= n2;
//      else if (n == n2)
//        n <= n3;
//      else if (n == n3)
//        n <= n1;
//    end
  
//endmodule

//  module light_FSM(clk,red,green);
//  input clk;
//  reg state;
//  output reg red;
//  output reg green;
//  reg [2:0] count;
//  reg signal;
//  wire clk_d;
//  wire [2:0] param;
  
    
//    initial begin
//    state = 1;
//    count = 0;
//    signal = 0;
//  end
  
//  clk_div_new c(clk,clk_d);
//  random r(signal, param);
  
  
//  always @(posedge clk_d)
//    begin
//      if (count == param)
//        begin
//          count <= 0;
//          signal <= 1;
//        end
         
      	
//    else
//      begin
//        count <= count +1;
//        signal <= 0;
//      end
      
//    end
  
//  always @(posedge clk_d)
//    begin
//      if (count == param)
//        state <= ~state;
      
//    end
    
//    always @(posedge clk_d)
//    begin
//    green = state;
//    red = ~state;
//    end
//    endmodule


module clk_div_heart (clk, clk_d);
  parameter div_value = 12499999;
  input clk;
  output clk_d;
  reg clk_d;
  reg [25:0] count; 
  
  initial 
    begin
      clk_d = 0;
      count = 0;
    end
  
  always @(posedge clk)
    begin
      if (count == div_value)
        count <= 0;
      else
        count <= count + 1;
    end
  
  always @(posedge clk)
    begin
      if (count == div_value)
        clk_d <= ~clk_d;
    end 
endmodule 

module DFF(d, clk, reset, q, qnot);
input d; // Data input 
input clk, reset; // clock input 
output reg q, qnot; // output Q 
always @(posedge clk)
  begin 
    if (reset == 1)
      begin
        q <= 0;
        qnot <= 1; 
      end
    else
      begin 
        q <= d;
        qnot <= ~d;
      end 
  end
endmodule

module top(x,y,clk,reset,C);
  input x, y, clk, reset;
  output [1:0] C;
  wire clk_d;
  wire dA, dB, A, B;
  
  clk_div_heart g0(clk, clk_d);
  
  assign dA = (A) || (B&&x&&y);
  assign dB = (B&&~x) || (B&&~y) || (A&&B) || (~B&&x&&y);
  
  DFF g1(dA, clk_d, reset, A, ~A);
  DFF g2(dB, clk_d, reset, B, ~B);
  
  assign C[0] = (~A);
  assign C[1] = (~B);
  
  
  
endmodule

 
module TopLevelModule(clk, ps2_clk, ps2_data, red, green, blue, h_sync, v_sync);
input clk;
input ps2_clk;
input ps2_data;
output [3:0]red;
output [3:0]green;
output [3:0]blue;
output h_sync;
output v_sync;
 
wire M1,M3,M7;
wire [9:0] M2, M4,M8,M9;
 
clk_div a1(clk,M1);
h_counter a2(M1,M2,M3);
v_counter a3(M1,M3, M4);
vga_sync a4(M2, M4, h_sync, v_sync, M7,M8,M9);
pixel_gen a5(M1, M8, M9, M7, ps2_clk, ps2_data, red, green, blue);
endmodule
 
module vga_sync(h_count, v_count, h_sync, v_sync, video_on, x_loc, y_loc);
input [9:0] h_count;
input [9:0] v_count;
output h_sync;
output v_sync;
output video_on;
output [9:0] x_loc;
output [9:0] y_loc;
 
//horizontal
localparam HD = 640;
localparam HF = 48;
localparam HB = 16;
localparam HR = 96;
 
//vertical
localparam VD = 480;
localparam VF = 10;
localparam VB = 33;
localparam VR = 2;
 

  assign h_sync = ((h_count < (HD+HF)) || (h_count >= (HD+HF+HR)));

  
  assign v_sync = ((v_count < (VD+VF)) || (v_count >= (VD+VF+VR)));

  
  assign video_on = ((h_count < HD) && (v_count < VD));

  
  
  assign x_loc = h_count; 
  assign y_loc = v_count; 
  
endmodule

module wonscreen(pixel_x, pixel_y, flag);
  input [9:0] pixel_x;
  input [9:0] pixel_y;
  output flag;
  
  reg [0:29] wonscreen [29:0];
  
  wire [5:0] x = pixel_x[9:4] - 5;
  wire [5:0] y = pixel_y[9:4];
  assign flag = wonscreen[y][x];
  
  initial begin
    wonscreen[0]  = 30'b110110110110110011011011011011; //0
    wonscreen[1]  = 30'b000000000000000000000000000000; //1
    wonscreen[2]  = 30'b000000000000000000000000000000; //2
    wonscreen[3]  = 30'b000000000000000000000000000000; //3
    wonscreen[4]  = 30'b000000000000000000000000000000; //4
    wonscreen[5]  = 30'b010000010001110000010000001000; //5
    wonscreen[6]  = 30'b001000100010001000010000001000; //6
    wonscreen[7]  = 30'b000101000100000100010000001000; //7
    wonscreen[8]  = 30'b000010001000000010010000001000; //8
    wonscreen[9]  = 30'b000010000100000100001000001000; //9
    wonscreen[10] = 30'b000010000010001000000100010000; //10
    wonscreen[11] = 30'b000010000001110000000011100000; //11
    wonscreen[12] = 30'b000000000000000000000000000000; //12
    wonscreen[13] = 30'b000000000000000000000000000000; //13
    wonscreen[14] = 30'b000100000100011100001000000010; //14
    wonscreen[15] = 30'b000100000100100010001100000010; //15
    wonscreen[16] = 30'b000100000101000001001010000010; //16
    wonscreen[17] = 30'b000100000101000001001001000010; //17
    wonscreen[18] = 30'b000100100101000001001000100010; //18
    wonscreen[19] = 30'b000101010101000001001000010010; //19
    wonscreen[20] = 30'b000101010101000001001000001010; //20
    wonscreen[21] = 30'b000110001100100010001000000110; //21
    wonscreen[22] = 30'b000100000100011100001000000010; //22
    wonscreen[23] = 30'b000000000000000000000000000000; //23
    wonscreen[24] = 30'b000000000000000000000000000000; //24
    wonscreen[25] = 30'b000000000000000000000000000000; //25
    wonscreen[26] = 30'b000000000000000000000000000000; //26
    wonscreen[27] = 30'b000000000000000000000000000000; //27
    wonscreen[28] = 30'b000000000000000000000000000000; //28
    wonscreen[29] = 30'b110110110110110011011011011011; //29
  end
endmodule


module startup(pixel_x, pixel_y, squad);
  input [9:0] pixel_x;
  input [9:0] pixel_y;
  output squad;
  
  reg [0:29] startup [29:0];
  
  wire [5:0] x = pixel_x[9:4] - 5;
  wire [5:0] y = pixel_y[9:4];
  assign squad = startup[y][x];
  
  initial begin
    startup[0]  = 30'b111111111111111111111111111111; 
    startup[1]  = 30'b100000000000000000000000000001; 
    startup[2]  = 30'b100000000000000000000000000001; 
    startup[3]  = 30'b100000000000000000000000000001; 
    startup[4]  = 30'b100000000000000000000000000001; 
    startup[5]  = 30'b100000000000000000000000000001; 
    startup[6]  = 30'b100000000000000000000000000001; 
    startup[7]  = 30'b100000000000000000000000000001; 
    startup[8]  = 30'b100000111011101010111011100001; 
    startup[9]  = 30'b100000100010101010010010100001; 
    startup[10] = 30'b100000111010101010010010100001; 
    startup[11] = 30'b100000001010101010010010100001; 
    startup[12] = 30'b100000001010101010010010100001; 
    startup[13] = 30'b100000111011101110111011100001; 
    startup[14] = 30'b100000000001000000000000000001;
    startup[15] = 30'b100000000000000000000000000001;
    startup[16] = 30'b100000111011101010111011100001; 
    startup[17] = 30'b100000100010101010101010100001; 
    startup[18] = 30'b100000111010101010111010100001; 
    startup[19] = 30'b100000001010101010101010100001; 
    startup[20] = 30'b100000001010101010101010100001; 
    startup[21] = 30'b100000111011101110101011100001; 
    startup[22] = 30'b100000000001000000000000000001; 
    startup[23] = 30'b100000000000000000000000000001; 
    startup[24] = 30'b100000000000000000000000000001; 
    startup[25] = 30'b100000000000000000000000000001; 
    startup[26] = 30'b100000000000000000000000000001; 
    startup[27] = 30'b100000000000000000000000000001; 
    startup[28] = 30'b100000000000000000000000000001; 
    startup[29] = 30'b111111111111111111111111111111; 
  end
endmodule

module lossscreen(pixel_x, pixel_y, flag);
  input [9:0] pixel_x;
  input [9:0] pixel_y;
  output flag;
  
  reg [0:29] lossscreen [29:0];
  
  wire [5:0] x = pixel_x[9:4] - 5;
  wire [5:0] y = pixel_y[9:4];
  assign flag = lossscreen[y][x];
  
  initial begin
    lossscreen[0]  = 30'b110110110110110011011011011011; //0
    lossscreen[1]  = 30'b000000000000000000000000000000; //1
    lossscreen[2]  = 30'b000000000000000000000000000000; //2
    lossscreen[3]  = 30'b000000000000000000000000000000; //3
    lossscreen[4]  = 30'b000000000000000000000000000000; //4
    lossscreen[5]  = 30'b010000010001110000010000001000; //5
    lossscreen[6]  = 30'b001000100010001000010000001000; //6
    lossscreen[7]  = 30'b000101000100000100010000001000; //7
    lossscreen[8]  = 30'b000010001000000010010000001000; //8
    lossscreen[9]  = 30'b000010000100000100001000001000; //9
    lossscreen[10] = 30'b000010000010001000000100010000; //10
    lossscreen[11] = 30'b000010000001110000000011100000; //11
    lossscreen[12] = 30'b000000000000000000000000000000; //12
    lossscreen[13] = 30'b000000000000000000000000000000; //13
    lossscreen[14] = 30'b010000011110011100001111111100; //14
    lossscreen[15] = 30'b010000010010100000001100000000; //15
    lossscreen[16] = 30'b010000010010100000001100000000; //16
    lossscreen[17] = 30'b010000010010100000001100000000; //17
    lossscreen[18] = 30'b010000010010111100001111110000; //18
    lossscreen[19] = 30'b010000010010000110001100000000; //19
    lossscreen[20] = 30'b010000010010000110001100000000; //20
    lossscreen[21] = 30'b010000010010000110001100000000; //21
    lossscreen[22] = 30'b011111011110111100001111111100; //22
    lossscreen[23] = 30'b000000000000000000000000000000; //23
    lossscreen[24] = 30'b000000000000000000000000000000; //24
    lossscreen[25] = 30'b000000000000000000000000000000; //25
    lossscreen[26] = 30'b000000000000000000000000000000; //26
    lossscreen[27] = 30'b000000000000000000000000000000; //27
    lossscreen[28] = 30'b000000000000000000000000000000; //28
    lossscreen[29] = 30'b110110110110110011011011011011; //29
  end
endmodule



 module red_light(pixel_x, pixel_y, light);
  input [9:0] pixel_x;
  input [9:0] pixel_y;
  output light;
  
  reg [0:19] red_arr [19:0];
  
   assign light = (((530 <= pixel_x) && (pixel_x< 530 + 20)) && ((110 <= pixel_y) && (pixel_y < 110 + 20))) ? (red_arr[pixel_y - 110][pixel_x - 530]):0;
  initial begin                                      
      red_arr[0]  = 19'b0000000000000000000;   
      red_arr[1]  = 19'b0000000000000000000;   
      red_arr[2]  = 19'b0000000000000000000;    
      red_arr[3]  = 19'b0000000000000000000;   
      red_arr[4]  = 19'b0000011111110000000;   
      red_arr[5]  = 19'b0000111111111100000;   
      red_arr[6]  = 19'b0011111111111110000;   
      red_arr[7]  = 19'b0111111111111111000;   
      red_arr[8]  = 19'b1111111111111111100;   
      red_arr[9]  = 19'b1111111111111111100;   
      red_arr[10] = 19'b1111111111111111100;   
      red_arr[11] = 19'b1111111111111111100;   
      red_arr[12] = 19'b0111111111111111100;   
      red_arr[13] = 19'b0111111111111111000;   
      red_arr[14] = 19'b0011111111111110000;
      red_arr[15] = 19'b0001111111111100000;  
      red_arr[16] = 19'b0000111111110000000;  
      red_arr[17] = 19'b0000000000000000000;  
      red_arr[18] = 19'b0000000000000000000;
      red_arr[19]  = 19'b000000000000000000;      
  end                                                
endmodule
 
 
 module green_light(pixel_x, pixel_y, light);
  input [9:0] pixel_x;
  input [9:0] pixel_y;
  output light;
  
  reg [0:19] green_arr [19:0];
  
   assign light = (((530 <= pixel_x) && (pixel_x< 530 + 20)) && ((75 <= pixel_y) && (pixel_y < 75 + 20))) ? (green_arr[pixel_y - 75][pixel_x - 530]):0;
  initial begin                                      
      green_arr[0]  = 19'b0000000000000000000;   
      green_arr[1]  = 19'b0000000000000000000;   
      green_arr[2]  = 19'b0000000000000000000;    
      green_arr[3]  = 19'b0000000000000000000;   
      green_arr[4]  = 19'b0000011111110000000;   
      green_arr[5]  = 19'b0000111111111100000;   
      green_arr[6]  = 19'b0011111111111110000;   
      green_arr[7]  = 19'b0111111111111111000;   
      green_arr[8]  = 19'b1111111111111111100;   
      green_arr[9]  = 19'b1111111111111111100;   
      green_arr[10] = 19'b1111111111111111100;   
      green_arr[11] = 19'b1111111111111111100;   
      green_arr[12] = 19'b0111111111111111100;   
      green_arr[13] = 19'b0111111111111111000;   
      green_arr[14] = 19'b0011111111111110000;
      green_arr[15] = 19'b0001111111111100000;  
      green_arr[16] = 19'b0000111111110000000;  
      green_arr[17] = 19'b0000000000000000000;  
      green_arr[18] = 19'b0000000000000000000;
      green_arr[19]  = 19'b000000000000000000;      
  end                                                
endmodule
 
 module maze(pixel_x, pixel_y, flag);
  input [9:0] pixel_x;
  input [9:0] pixel_y;
  output flag;
  
  reg [0:29] m [29:0];
  
  wire [5:0] x = pixel_x[9:4] - 5;
  wire [5:0] y = pixel_y[9:4];
  assign flag = m[y][x];
  
  initial begin
    m[0]  = 30'b000000000000000000000000000000;
    m[1]  = 30'b111111111100000000001111111111;
    m[2]  = 30'b000000000000000000000000000000;
    m[3]  = 30'b000000000000000000000000111111;
    m[4]  = 30'b000000001000000000000000100000;
    m[5]  = 30'b111111111000000000000000100000;
    m[6]  = 30'b000000000000000000000000000000;
    m[7]  = 30'b000000000000100000000000000000;
    m[8]  = 30'b000000000000111111111110000000;
    m[9]  = 30'b010000001111100000000000000000;
    m[10] = 30'b000000000000100000000000000000;
    m[11] = 30'b111110001111100000000000011111;
    m[12] = 30'b000000000000000000000000000000;
    m[13] = 30'b111111000000000000000000000000;
    m[14] = 30'b000000000000000000100000000000;
    m[15] = 30'b000000000000000000100000000000;
    m[16] = 30'b000000000000011111111000000000;
    m[17] = 30'b000000000000010000000000000000;
    m[18] = 30'b000000000000010000000000000000;
    m[19] = 30'b111100000000010000000000000010;
    m[20] = 30'b000000000000010000000000000010;
    m[21] = 30'b000000000000000000000000000010;
    m[22] = 30'b000000000000000000000000000010;
    m[23] = 30'b011111000000000000000011111110;
    m[24] = 30'b010000000000000000000000000000;
    m[25] = 30'b010000000111111100000000000000;
    m[26] = 30'b010000000000000000000000000000;
    m[27] = 30'b010000000000011110000001110000;
    m[28] = 30'b000000000000000000000000000000;
    m[29] = 30'b000000000000000000000000000000;  
  end
endmodule
 
 module finish(pixel_x, pixel_y, flag);
  input [9:0] pixel_x;
  input [9:0] pixel_y;
  output flag;
  
  reg [0:19] finish_arr [19:0];
  
   assign flag = (((312 <= pixel_x) && (pixel_x< 312 + 20)) && ((10 <= pixel_y) && (pixel_y < 10 + 20))) ? (finish_arr[pixel_y - 10][pixel_x - 312]):0;
  initial begin                                      
      finish_arr[0]  = 19'b0000000000000000000;   
      finish_arr[1]  = 19'b0000000000000000000;   
      finish_arr[2]  = 19'b1111111111111111100;   
      finish_arr[3]  = 19'b1110000000000000100;  
      finish_arr[4]  = 19'b1110011111111000100;   
      finish_arr[5]  = 19'b1110010000001000100;   
      finish_arr[6]  = 19'b1110010000001000100;   
      finish_arr[7]  = 19'b1110011111111000100;   
      finish_arr[8]  = 19'b1110000000000000100;   
      finish_arr[9]  = 19'b1110000000000000100;   
      finish_arr[10] = 19'b1111111111111111100;   
      finish_arr[11] = 19'b1110000000000000000;   
      finish_arr[12] = 19'b1110000000000000000;   
      finish_arr[13] = 19'b1110000000000000000;   
      finish_arr[14] = 19'b1110000000000000000;   
      finish_arr[15] = 19'b1110000000000000000;
      finish_arr[16] = 19'b1110000000000000000;  
      finish_arr[17] = 19'b0000000000000000000;  
      finish_arr[18] = 19'b0000000000000000000;  
      finish_arr[19] = 19'b0000000000000000000;     
  end                                                
endmodule
 
 module oneheart(pixel_x, pixel_y, flag);
  input [9:0] pixel_x;
  input [9:0] pixel_y;
  output flag;
  
 reg [0:29] heart_arr [29:0];
  
  
  assign flag = (((450 <= pixel_x) && (pixel_x< 450 + 30)) && ((450 <= pixel_y) && (pixel_y < 450 + 30))) ? (heart_arr[pixel_y - 450][pixel_x - 450]):0;
  
  
  initial begin
    heart_arr[0]  = 30'b000000000000000000000000000000;   
    heart_arr[1]  = 30'b000000000000000000000000000000;   
    heart_arr[2]  = 30'b000000000000000000000000000000;  
    heart_arr[3]  = 30'b000000000000000000000000000000;  
    heart_arr[4]  = 30'b000000000000000000000000000000;    
    heart_arr[5]  = 30'b000000000000000000000000000000;   
    heart_arr[6]  = 30'b000000000000000000000000000000;    
    heart_arr[7]  = 30'b000000000000000000000000000000;    
    heart_arr[8]  = 30'b011101110000000000000000000000;     
    heart_arr[9]  = 30'b111101111000000000000000000000;  
    heart_arr[10] = 30'b011111110000000000000000000000;     
    heart_arr[11] = 30'b001111100000000000000000000000;  
    heart_arr[12] = 30'b000111000000000000000000000000;  
    heart_arr[13] = 30'b000010000000000000000000000000;  
    heart_arr[14] = 30'b000000000000000000000000000000; 
    heart_arr[15] = 30'b000000000000000000000000000000;   
    heart_arr[16] = 30'b000000000000000000000000000000;   
    heart_arr[17] = 30'b000000000000000000000000000000;  
    heart_arr[18] = 30'b000000000000000000000000000000;  
    heart_arr[19] = 30'b000000000000000000000000000000;    
    heart_arr[20] = 30'b000000000000000000000000000000;   
    heart_arr[21] = 30'b000000000000000000000000000000;    
    heart_arr[22] = 30'b000000000000000000000000000000;    
    heart_arr[23] = 30'b000000000000000000000000000000;     
    heart_arr[24] = 30'b000000000000000000000000000000;  
    heart_arr[25] = 30'b000000000000000000000000000000;     
    heart_arr[26] = 30'b000000000000000000000000000000;  
    heart_arr[27] = 30'b000000000000000000000000000000;  
    heart_arr[28] = 30'b000000000000000000000000000000;  
    heart_arr[29] = 30'b000000000000000000000000000000; 
  end
endmodule

module twoheart(pixel_x, pixel_y, flag);
  input [9:0] pixel_x;
  input [9:0] pixel_y;
  output flag;
  
  reg [0:29] heart_arr [29:0];
  
  
  assign flag = (((450 <= pixel_x) && (pixel_x< 450 + 30)) && ((450 <= pixel_y) && (pixel_y < 450 + 30))) ? (heart_arr[pixel_y - 450][pixel_x - 450]):0;
  
  
  initial begin
    heart_arr[0]  = 30'b000000000000000000000000000000;   
    heart_arr[1]  = 30'b000000000000000000000000000000;   
    heart_arr[2]  = 30'b000000000000000000000000000000;  
    heart_arr[3]  = 30'b000000000000000000000000000000;  
    heart_arr[4]  = 30'b000000000000000000000000000000;    
    heart_arr[5]  = 30'b000000000000000000000000000000;   
    heart_arr[6]  = 30'b000000000000000000000000000000;    
    heart_arr[7]  = 30'b000000000000000000000000000000;    
    heart_arr[8]  = 30'b011101110001110111000000000000;     
    heart_arr[9]  = 30'b111101111011110111100000000000;  
    heart_arr[10] = 30'b011111110001111111000000000000;     
    heart_arr[11] = 30'b001111100000111110000000000000;  
    heart_arr[12] = 30'b000111000000011100000000000000;  
    heart_arr[13] = 30'b000010000000001000000000000000;  
    heart_arr[14] = 30'b000000000000000000000000000000; 
    heart_arr[15] = 30'b000000000000000000000000000000;   
    heart_arr[16] = 30'b000000000000000000000000000000;   
    heart_arr[17] = 30'b000000000000000000000000000000;  
    heart_arr[18] = 30'b000000000000000000000000000000;  
    heart_arr[19] = 30'b000000000000000000000000000000;    
    heart_arr[20] = 30'b000000000000000000000000000000;   
    heart_arr[21] = 30'b000000000000000000000000000000;    
    heart_arr[22] = 30'b000000000000000000000000000000;    
    heart_arr[23] = 30'b000000000000000000000000000000;     
    heart_arr[24] = 30'b000000000000000000000000000000;  
    heart_arr[25] = 30'b000000000000000000000000000000;     
    heart_arr[26] = 30'b000000000000000000000000000000;  
    heart_arr[27] = 30'b000000000000000000000000000000;  
    heart_arr[28] = 30'b000000000000000000000000000000;  
    heart_arr[29] = 30'b000000000000000000000000000000; 
  end
endmodule

module threeheart(pixel_x, pixel_y, flag);
  input [9:0] pixel_x;
  input [9:0] pixel_y;
  output flag;
  
  reg [0:29] heart_arr [29:0];
  
  
  assign flag = (((450 <= pixel_x) && (pixel_x< 450 + 30)) && ((450 <= pixel_y) && (pixel_y < 450 + 30))) ? (heart_arr[pixel_y - 450][pixel_x - 450]):0;

  
  
  initial begin
    heart_arr[0]  = 30'b000000000000000000000000000000;   
    heart_arr[1]  = 30'b000000000000000000000000000000;   
    heart_arr[2]  = 30'b000000000000000000000000000000;  
    heart_arr[3]  = 30'b000000000000000000000000000000;  
    heart_arr[4]  = 30'b000000000000000000000000000000;    
    heart_arr[5]  = 30'b000000000000000000000000000000;   
    heart_arr[6]  = 30'b000000000000000000000000000000;    
    heart_arr[7]  = 30'b000000000000000000000000000000;    
    heart_arr[8]  = 30'b011101110001110111000111011100;     
    heart_arr[9]  = 30'b111101111011110111101111011110;  
    heart_arr[10] = 30'b011111110001111111000111111100;     
    heart_arr[11] = 30'b001111100000111110000011111000;  
    heart_arr[12] = 30'b000111000000011100000001110000;  
    heart_arr[13] = 30'b000010000000001000000000100000;  
    heart_arr[14] = 30'b000000000000000000000000000000; 
    heart_arr[15] = 30'b000000000000000000000000000000;   
    heart_arr[16] = 30'b000000000000000000000000000000;   
    heart_arr[17] = 30'b000000000000000000000000000000;  
    heart_arr[18] = 30'b000000000000000000000000000000;  
    heart_arr[19] = 30'b000000000000000000000000000000;    
    heart_arr[20] = 30'b000000000000000000000000000000;   
    heart_arr[21] = 30'b000000000000000000000000000000;    
    heart_arr[22] = 30'b000000000000000000000000000000;    
    heart_arr[23] = 30'b000000000000000000000000000000;     
    heart_arr[24] = 30'b000000000000000000000000000000;  
    heart_arr[25] = 30'b000000000000000000000000000000;     
    heart_arr[26] = 30'b000000000000000000000000000000;  
    heart_arr[27] = 30'b000000000000000000000000000000;  
    heart_arr[28] = 30'b000000000000000000000000000000;  
    heart_arr[29] = 30'b000000000000000000000000000000; 
  end
endmodule
 
 
module player(clk, ps2_clk, ps2_data, pixel_x, pixel_y, flag, maze_pix, gameend);
  input clk;
  input ps2_clk;
  input ps2_data;
  input [9:0] pixel_x;
  input maze_pix;
  output gameend;
  
  input [9:0] pixel_y;
  reg [3:0]red;
  reg [3:0]green;
  reg [3:0]blue;
  reg [9:0] xpos;
  reg [9:0] ypos;
  reg [3:0] collision = 0;
  reg animate;
  reg gameend;
  reg videoon;

  output flag;
  wire clk_d;
  clk_div_new cd(clk,clk_d);
  wire up, down, left, right, space;
  Keyboard(clk, ps2_clk, ps2_data, up, down, left, right, space);
  
  initial
  begin
  gameend = 0;
  end
  
  
  /*always @(posedge clk)
    begin
    if (left == 0) begin
    xpos = xpos + 0;
    end
    else if (left == 1) begin
    xpos = xpos - 30;
    end
    end*/
    initial begin
    xpos = 210;
    ypos = 450;
    end
    
    
    //yahan se comment krnaaa
    always @(posedge clk) begin
    if (maze_pix == 1) begin
        if (pixel_y == ypos && ((xpos + 1 <= pixel_x) && (pixel_x<= xpos + 14))) collision[0] = 1;
        if (pixel_y == ypos+15 && ((xpos + 1 <= pixel_x) && (pixel_x< xpos + 14))) collision[1] = 1;
        if (pixel_x == xpos && ((ypos + 1 <= pixel_y) && (pixel_y < ypos + 14))) collision[2] = 1;
        if (pixel_x == xpos+15 && ((ypos + 1 <= pixel_y) && (pixel_y < ypos + 14))) collision[3] = 1;
    
    end
    if (pixel_y == 481 && pixel_x == 0) begin
//        if (pixel_y == y_pos && ((x_pos <= pixel_x) && (pixel_x< x_pos + 15))) collision[0] = 0;
//        if (pixel_y == y_pos+15 && ((x_pos <= pixel_x) && (pixel_x< x_pos + 15))) collision[1] = 0;
//        if (pixel_x == x_pos && ((y_pos <= pixel_y) && (pixel_y < y_pos + 15))) collision[2] = 0;
//        if (pixel_x == x_pos+15 && ((y_pos <= pixel_y) && (pixel_y < y_pos + 15))) collision[3] = 0;
//        if (fire_flag == 1) fire_reset = 0;
        collision = 0;
 
    end
    animate <= (pixel_y == 480 && pixel_x == 0); 
  end
  
  always @(posedge animate) begin
     if (down == 1 && collision[1] == 0) begin
      
        ypos <= ypos + 1;
    
    end
    else if (up == 1 && collision[0] == 0) begin
      
        ypos <= ypos - 1;
     
    end
    else if (left == 1 && collision[2] == 0) begin
        
        xpos <= xpos - 1;
      
    end
    else if (right == 1 && collision[3] == 0) begin
        
        xpos <= xpos + 1;
  
    end
    
    else if(right ==0 && left == 0 && up == 0 && down == 0 && space == 0) begin
    xpos = xpos + 0;
    ypos = ypos + 0;
    end
    
  end
  
  
  always @(posedge clk)
    begin
    if (ypos <= 30)
    begin
    gameend = 1;
    end
    else
    begin
    gameend = 0;
    end
    end
  //yahan tak krna
    //always @(posedge clk_d)
    /*if (maze_pix == 1) begin
        if (pixel_y == ypos && ((xpos + 5 <= pixel_x) && (pixel_x<= xpos + 14))) collision[0] = 1;
        if (pixel_y == ypos+15 && ((xpos + 5 <= pixel_x) && (pixel_x< xpos + 14))) collision[1] = 1;
        if (pixel_x == xpos && ((ypos + 5 <= pixel_y) && (pixel_y < ypos + 14))) collision[2] = 1;
        if (pixel_x == xpos+15 && ((ypos + 5 <= pixel_y) && (pixel_y < ypos + 14))) collision[3] = 1;
     end*/
        
        
   /* begin
        if (right == 1) begin
             if (((pixel_y>=16 && pixel_y<32) || (pixel_y>=48 && pixel_y<64) || (pixel_y>=64 && pixel_y<80) || (pixel_y>=80 && pixel_y<96) ||(pixel_y>=112 && pixel_y<128) || (pixel_y>=128 && pixel_y<144) || (pixel_y>=144 && pixel_y<160) || (pixel_y>=160 && pixel_y<176) || (pixel_y>=176 && pixel_y<192) || (pixel_y>=208 && pixel_y<224) || (pixel_y>=224 && pixel_y<240) || (pixel_x>=80 && pixel_x<240) || (pixel_x>=400 && pixel_x<480) || (pixel_x>=464 && pixel_x<560) || (pixel_x>=208 && pixel_x<224)|| (pixel_x>=464 && pixel_x<480) || (pixel_x>=80 && pixel_x<224) || (pixel_x>=464 && pixel_x<480) || (pixel_x>=272 && pixel_x<288) || (pixel_x>=272 && pixel_x<448) || (pixel_x>=96 && pixel_x<112) || (pixel_x>=208 && pixel_x<288) || (pixel_x>=272 && pixel_x<288) || (pixel_x>=80 && pixel_x<160) || (pixel_x>=208 && pixel_x<288) || (pixel_x>=480 && pixel_x<560) || (pixel_x>=80 && pixel_x<176) || (pixel_x>=368 && pixel_x<384))) 
             begin
             xpos = xpos + 0;
             end 
             else 
             begin
             xpos = xpos + 5;
             end
        end
        else if (left == 1) begin
              if (((pixel_y>=16 && pixel_y<32) || (pixel_y>=48 && pixel_y<64) || (pixel_y>=64 && pixel_y<80) || (pixel_y>=80 && pixel_y<96) ||(pixel_y>=112 && pixel_y<128) || (pixel_y>=128 && pixel_y<144) || (pixel_y>=144 && pixel_y<160) || (pixel_y>=160 && pixel_y<176) || (pixel_y>=176 && pixel_y<192) || (pixel_y>=208 && pixel_y<224) || (pixel_y>=224 && pixel_y<240) || (pixel_x>=80 && pixel_x<240) || (pixel_x>=400 && pixel_x<480) || (pixel_x>=464 && pixel_x<560) || (pixel_x>=208 && pixel_x<224)|| (pixel_x>=464 && pixel_x<480) || (pixel_x>=80 && pixel_x<224) || (pixel_x>=464 && pixel_x<480) || (pixel_x>=272 && pixel_x<288) || (pixel_x>=272 && pixel_x<448) || (pixel_x>=96 && pixel_x<112) || (pixel_x>=208 && pixel_x<288) || (pixel_x>=272 && pixel_x<288) || (pixel_x>=80 && pixel_x<160) || (pixel_x>=208 && pixel_x<288) || (pixel_x>=480 && pixel_x<560) || (pixel_x>=80 && pixel_x<176) || (pixel_x>=368 && pixel_x<384))) 
              begin
              xpos = xpos + 0;
              end
              else
              begin
              xpos = xpos-5;
              end 
        //xpos = xpos - 5;
        end
        else if (up == 1) begin
        if (((pixel_y>=16 && pixel_y<32) || (pixel_y>=48 && pixel_y<64) || (pixel_y>=64 && pixel_y<80) || (pixel_y>=80 && pixel_y<96) ||(pixel_y>=112 && pixel_y<128) || (pixel_y>=128 && pixel_y<144) || (pixel_y>=144 && pixel_y<160) || (pixel_y>=160 && pixel_y<176) || (pixel_y>=176 && pixel_y<192) || (pixel_y>=208 && pixel_y<224) || (pixel_y>=224 && pixel_y<240) || (pixel_x>=80 && pixel_x<240) || (pixel_x>=400 && pixel_x<480) || (pixel_x>=464 && pixel_x<560) || (pixel_x>=208 && pixel_x<224)|| (pixel_x>=464 && pixel_x<480) || (pixel_x>=80 && pixel_x<224) || (pixel_x>=464 && pixel_x<480) || (pixel_x>=272 && pixel_x<288) || (pixel_x>=272 && pixel_x<448) || (pixel_x>=96 && pixel_x<112) || (pixel_x>=208 && pixel_x<288) || (pixel_x>=272 && pixel_x<288) || (pixel_x>=80 && pixel_x<160) || (pixel_x>=208 && pixel_x<288) || (pixel_x>=480 && pixel_x<560) || (pixel_x>=80 && pixel_x<176) || (pixel_x>=368 && pixel_x<384))) 
              begin
              xpos = xpos + 0;
              end
              else
              begin
              ypos = ypos-5;
              end
        //ypos = ypos - 5;
        end
        else if (down == 1) begin
        if (((pixel_y>=16 && pixel_y<32) || (pixel_y>=48 && pixel_y<64) || (pixel_y>=64 && pixel_y<80) || (pixel_y>=80 && pixel_y<96) ||(pixel_y>=112 && pixel_y<128) || (pixel_y>=128 && pixel_y<144) || (pixel_y>=144 && pixel_y<160) || (pixel_y>=160 && pixel_y<176) || (pixel_y>=176 && pixel_y<192) || (pixel_y>=208 && pixel_y<224) || (pixel_y>=224 && pixel_y<240) || (pixel_x>=80 && pixel_x<240) || (pixel_x>=400 && pixel_x<480) || (pixel_x>=464 && pixel_x<560) || (pixel_x>=208 && pixel_x<224)|| (pixel_x>=464 && pixel_x<480) || (pixel_x>=80 && pixel_x<224) || (pixel_x>=464 && pixel_x<480) || (pixel_x>=272 && pixel_x<288) || (pixel_x>=272 && pixel_x<448) || (pixel_x>=96 && pixel_x<112) || (pixel_x>=208 && pixel_x<288) || (pixel_x>=272 && pixel_x<288) || (pixel_x>=80 && pixel_x<160) || (pixel_x>=208 && pixel_x<288) || (pixel_x>=480 && pixel_x<560) || (pixel_x>=80 && pixel_x<176) || (pixel_x>=368 && pixel_x<384))) 
              begin
              xpos = xpos + 0;
              end
              else
              begin
              ypos = ypos+5;
              end
        //ypos = ypos + 5;
        end
    end*/
    /*
      always @ (posedge clk_d)
    begin 
    if ((pixel_y>=16 && pixel_y<32 && pixel_x>=80 && pixel_x<240) || (pixel_y>=16 && pixel_y<32 && pixel_x>=400 && pixel_x<480) || (pixel_y>=48 && pixel_y<64&& pixel_x>=464 && pixel_x<560)|| (pixel_y>=64 && pixel_y<80 && pixel_x>=208 && pixel_x<224) ||(pixel_y>=64 && pixel_y<80 && pixel_x>=464 && pixel_x<480) ||(pixel_y>=80 && pixel_y<96 && pixel_x>=80 && pixel_x<224) || (pixel_y>=80 && pixel_y<96 && pixel_x>=464 && pixel_x<480) || (pixel_y>=112 && pixel_y<128 && pixel_x>=272 && pixel_x<288) || (pixel_y>=128 && pixel_y<144 && pixel_x>=272 && pixel_x<448) || (pixel_y>=144 && pixel_y<160 && pixel_x>=96 && pixel_x<112) || (pixel_y>=144 && pixel_y<160 && pixel_x>=208 && pixel_x<288) || (pixel_y>=160 && pixel_y<176 && pixel_x>=272 && pixel_x<288) || (pixel_y>=176 && pixel_y<192 && pixel_x>=80 && pixel_x<160) || (pixel_y>=176 && pixel_y<192 && pixel_x>=208 && pixel_x<288) || (pixel_y>=176 && pixel_y<192 && pixel_x>=480 && pixel_x<560) || (pixel_y>=208 && pixel_y<224 && pixel_x>=80 && pixel_x<176)|| (pixel_y>=224 && pixel_y<240 && pixel_x>=368 && pixel_x<384))
    begin
    if ((down == 1) || (right == 1) || (left == 1) || (right == 1))
    begin
     xpos = xpos + 0;
    end 
    end 
    else 
    begin
    if (left == 1) begin
    xpos = xpos - 5;
    end
    else if (right == 1) begin
    xpos = xpos + 5;
    end
    else if (up == 1) begin
    ypos = ypos - 5;
    end
    else if (down == 1) begin
    ypos = ypos + 5;
    end
    end
    end 
    */
  /*
    always @(posedge clk_d)
    begin
    if (left == 1 && collision[2] == 0) begin
    xpos = xpos - 5;
    end
    else if (right == 1 && collision[3] == 0) begin
    xpos = xpos + 5;
    end
    else if (up == 1 && collision[0] == 0) begin
    ypos = ypos - 5;
    end
    else if (down == 1 && collision[1] == 0) begin
    ypos = ypos + 5;
    end
    end
    */
    /*always @(posedge clk_d)
    begin
    if (up == 0) begin
    ypos = ypos + 0;
    end
    else if (up == 1) begin
    ypos = ypos + 5;
    end
    end
    
    always @(posedge clk_d)
    begin
    if (down == 0) begin
    ypos = ypos + 0;
    end
    else if (down == 1) begin
    ypos = ypos - 5;
    end
    end*/
  
  //parameter xpos = 210;
  //parameter ypos = 450; 
  
  reg [0:15] m [15:0];
  
   assign flag = (((xpos <= pixel_x) && (pixel_x< xpos + 16)) && ((ypos <= pixel_y) && (pixel_y < ypos + 16))) ? (m[pixel_y - ypos][pixel_x - xpos]):0;
  
  initial begin
    m[0]  = 16'b0000000000000000;
    m[1]  = 16'b0000011111100000;
    m[2]  = 16'b0000111111110000;
    m[3]  = 16'b0001111111111000;
    m[4] =  16'b0011111111111100;
    m[5] =  16'b0011111111111100;
    m[6] =  16'b0111111111111110;
    m[7] =  16'b0100010000100010;
    m[8] =  16'b0100010000100010;
    m[9] =  16'b0110000000000110;
    m[10] = 16'b0010000000000100;
    m[11] = 16'b0011000000001100;
    m[12] = 16'b0001000000001000;
    m[13] = 16'b0001111111111000;
    m[14] = 16'b0000000000000000;
    m[15] = 16'b0000000000000000;  
  end
endmodule
 
 
module pixel_gen( 
  input clk_d, // pixel clock 
  input [9:0] pixel_x, 
  input [9:0] pixel_y, 
  input video_on, 
  input ps2_clk,
  input ps2_data,
  //input gameend,
  output reg [3:0] red=0, 
  output reg [3:0] green=0, 
  output reg [3:0] blue=0
  //input [3:0] keys_1,
  //input [3:0] keys_2,
  //input fire_1,
  //input fire_2,
  //input startgame,
  //input restart
);
  parameter start = 2'b00;
  parameter game = 2'b01;
  parameter gamewon = 2'b10;
  parameter gameover = 2'b11;
  reg animate;
  wire [1:0] hearts;
  reg move;
  reg displayone;
  reg displaytwo;
  reg displaythree;
  //reg x = 0;
  //reg[9:0] xpos = 210;
  //reg[9:0] ypos = 450;
  //parameter p1 = 2;
  //parameter p2 = 3;
  //reg animate;
  //reg p1wincheck;
  //reg p2wincheck;
  //reg reset = 1;
  //reg [10:0] counter;
//  wire clk_vga;
  
//  clk_div c(clk_d,clk_vga);
  reg[1:0] state = start;
  wire s1_pix;
  startup s1(pixel_x, pixel_y, s1_pix);
  wire maze_pix;
  maze m1(pixel_x, pixel_y, maze_pix);
  
  wire player_pix, gameend;
  player p1(clk_d, ps2_clk, ps2_data, pixel_x, pixel_y, player_pix, maze_pix, gameend);
  wire finish_pix;
  finish f1(pixel_x, pixel_y, finish_pix);
  
  wire red_pix;
  red_light(pixel_x, pixel_y, red_pix);
  wire green_pix;
  green_light(pixel_x, pixel_y, green_pix);
  
  wire display_red, display_green;
  light_FSM(clk_d,display_red, display_green);
  
  wire up, down, left, right, space;
  Keyboard(clk_d, ps2_clk, ps2_data, up, down, left, right, space); 
  
  wire wonpix;
  wonscreen(pixel_x, pixel_y, wonpix);
  
  wire losspix;
  lossscreen(pixel_x, pixel_y, losspix);
  
  wire oneheart_pix;
  oneheart(pixel_x, pixel_y, oneheart_pix);
  
  wire twoheart_pix;
  twoheart(pixel_x, pixel_y, twoheart_pix);
  
  wire threeheart_pix;
  threeheart(pixel_x, pixel_y, threeheart_pix);
  
  
  always @(posedge clk_d) begin
  if (up == 1 || right == 1 || left == 1 || down == 1) begin //ctrl button not pressed
     move = 1;
  end
  else begin
  move = 0;
  end
  end
  
  wire resett;
  top(display_red,move,clk_d,resett,hearts);
  
  
  always @(posedge clk_d) begin
  if (hearts == 2'b11) begin
  displaythree = 1;
  displaytwo = 0;
  displayone = 0;
  end
  else if (hearts == 2'b10) begin
  displaytwo=0;
  displaythree = 0;
  displayone = 1;
  end 
  else if (hearts == 2'b01) begin
  displaythree = 0;
  displaytwo = 1;
  displayone = 0;
  end 
  else if (hearts == 2'b00) begin
  displaythree = 0;
  displaytwo = 0;
  displayone = 0;
  end
  end
  
  //reg la,lb,lc,reset;
  
  //wire tank_pix_1;
  //wire fire_pix_1;
  //wire tank_pix_2;
  //wire fire_pix_2;
  //tank1 t1(clk_d, pixel_x, pixel_y, tank_pix_1, fire_pix_1, keys_1, fire_1, reset, maze_pix || crown_pix || tank_pix_2);
  //tank2 t2(clk_d, pixel_x, pixel_y, tank_pix_2, fire_pix_2, keys_2, fire_2, reset, maze_pix || crown_pix || tank_pix_1);
 
  //assign y_pos_1 = (pixel_x == 640&&pixel_y==480)? ((keys == 1)? (y_pos_1 + 1) : y_pos) : y_pos;
  //fire1 t2(clk_d, pixel_x, pixel_y, tank_pix_2, keys_2);
  //always @(posedge clk_d) begin
    //if ((tank_pix_2 == 1 && fire_pix_1 == 1) || (tank_pix_1 == 1 && crown_pix == 1 && counter >= 600)) p1wincheck = 1;
    //if (tank_pix_1 == 1 && fire_pix_2 == 1 || (tank_pix_2 == 1 && crown_pix == 1 && counter >= 600)) p2wincheck = 1;
    //if (pixel_y == 481 && pixel_x == 0) begin
      //  p1wincheck = 0;
      //  p2wincheck = 0;
    //end
    //animate <= (pixel_y == 480 && pixel_x == 0); 
  //end
  /*always @(posedge animate) begin
    if (counter < 750) counter = counter + 1;
    else counter = 0;
    if (state == start && startgame == 1) begin
        state = game;
        reset = 0;
        counter = 0;
    end
    else if ((state == p1 || state == p2) && restart == 1) begin
        state = start; 
        reset = 1;
    end
    else if (p1wincheck == 1 && state == game) state = p1; 
    else if (p2wincheck == 1 && state == game) state = p2; 
  end*/
  
 
  
  always @(posedge clk_d)
    begin
    if(space == 1 && state == start)
    begin
    state = game;
    end
    else if(displayone == 0 && displaytwo == 0 && displaythree == 0 && state == game) begin
    state = gameover;
    end
    else if(gameend == 1 && state == game)begin
    state = gamewon;
    end
    end
    
    
  
    
   /* always@(posedge clk_d)
    begin
    if ( display_red && (right==1 || left==1 || up==1 || down==1 || space==1))
    begin
    x = 1;
    lives(x,clk_d,reset,la,lb,lc);
    end
    end*/
    
    
  
  always @(posedge clk_d)
    begin
      if ((pixel_x <80) || (pixel_x >=560)) begin 
        red <= 4'h0; 
        green <= 4'h0; 
        blue <= 4'h0; 
      end
//      else if (pixel_x == 0) begin
//        red <= 4'h1; 
//        green <= 4'h1; 
//        blue <= 4'h1; 
//      end
      else begin
          if (state == start) begin
            if (s1_pix) begin
                red <= 4'hF; 
                green <= 4'h0; 
                blue <= 4'hF;
            end
            else begin
                red <= 4'hd;
                green <=4'hd;
                blue <= 4'he;
            end
          end  
          else if (state == game) begin     
              if (maze_pix == 1) begin 
                red <= 4'hd;
                green <= 4'hd; 
                blue <= 4'he; 
              end     
              else if (player_pix == 1) begin 
                red <= 4'h0;
                green <= 4'hf; 
                blue <= 4'hf; 
              end 
              /*else if (tank_pix_1 == 1 || fire_pix_1 == 1) begin
                red <= 4'hd; 
                green <= 4'h2; 
                blue <= 4'h2;
              end
              else if (tank_pix_2 == 1 || fire_pix_2 == 1) begin
                red <= 4'hf; 
                green <= 4'h7; 
                blue <= 4'h0;
              end*/
              else if (finish_pix == 1) begin
                red <= 4'he; 
                green <= 4'hc; 
                blue <= 4'h0;
              end
               else if (red_pix == 1 && display_red) begin
                red <= 4'hF; 
                green <= 4'h0; 
                blue <= 4'h0;
              end
              
              else if (green_pix == 1 && display_green) begin
                red <= 4'h0; 
                green <= 4'hF; 
                blue <= 4'h0;
              end
              
              else if(threeheart_pix==1 && displaythree) begin
                red <= 4'hF; 
                green <= 4'h0; 
                blue <= 4'h0;
              end
              
              else if(twoheart_pix==1 && displaytwo) begin
                red <= 4'hF; 
                green <= 4'h0; 
                blue <= 4'h0;
              end
              
             else if(oneheart_pix==1 && displayone) begin
                red <= 4'hF; 
                green <= 4'h0; 
                blue <= 4'h0;
              end
              /*else if(gameend == 1)
              begin
              if(wonpix) begin
                red <= 4'hF; 
                green <= 4'h0; 
                blue <= 4'hF;
              end
           end*/
              /*else if (JAM == 1 && counter >= 600) begin
                red <= 4'he; 
                green <= 4'h0; 
                blue <= 4'h0;
              end*/
              else
                begin
                red <= 4'h0;
                green <=4'h3;
                blue <= 4'h5;
              end
          end
           else if (state == gameover) begin
            if (losspix==1) begin
                red <= 4'hF; 
                green <= 4'h0; 
                blue <= 4'hF;
            end
            else begin
                red <= 4'hd;
                green <=4'hd;
                blue <= 4'he;
            end
          end
          else if (state == gamewon) begin
            if (wonpix==1) begin
                red <= 4'hF; 
                green <= 4'h0; 
                blue <= 4'hF;
            end
            else begin
                red <= 4'hd;
                green <=4'hd;
                blue <= 4'he;
            end
          end
          /*else if (state == p2) begin
            if (p2_pix == 1) begin
                red <= 4'hf; 
                green <= 4'h7; 
                blue <= 4'h0;
            end
            else begin
                red <= 4'hd;
                green <=4'hd;
                blue <= 4'he;
            end
          end*/
      end
     end 
endmodule

 
module h_counter(clk,h_count,trig_v);
input clk;
output [9:0] h_count;
reg [9:0] h_count;
output trig_v;
reg trig_v;
initial h_count = 0;
initial trig_v = 0;
 
always @ (posedge clk)
begin
if (h_count <= 798)
begin
h_count <= h_count +1;
trig_v <= 0;
end
else
begin
h_count <= 0;
trig_v <= 1;
end
end
endmodule
 
module v_counter(clk,enable_v, v_count);
input clk;
input enable_v;
output [9:0] v_count;
reg [9:0] v_count;
initial v_count = 0;
 
always @ (posedge clk)
begin
if (enable_v ==1)
begin
if (v_count <= 523)
begin
v_count <= v_count + 1;
end
else
begin
v_count <= 0;
end
end
end
endmodule
 
module clk_div (clk, clk_d);
parameter div_value = 1;
input clk;
output clk_d;
 
reg clk_d;
reg count;
 
initial
begin
clk_d = 0;
count = 0;
end
always @(posedge clk)
begin
if (count == div_value)
count <= 0; // reset count
else
count <= count + 1; //count up
end
always @(posedge clk)
begin
if (count == div_value)
clk_d <= ~clk_d; //toggle
end
endmodule
